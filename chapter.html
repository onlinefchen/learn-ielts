<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç« èŠ‚å­¦ä¹  - IELTSè¯æ±‡</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <header>
            <div class="header-nav">
                <button onclick="window.location.href='index.html'" class="back-btn">â† è¿”å›ç« èŠ‚åˆ—è¡¨</button>
                <h1 id="chapter-title">åŠ è½½ä¸­...</h1>
            </div>
            <div class="controls">
                <select id="display-mode" class="filter-select">
                    <option value="learning">å­¦ä¹ ä¸­</option>
                    <option value="mastered">å·²æŒæ¡</option>
                    <option value="all">å…¨éƒ¨</option>
                </select>
                <select id="sort-mode" class="filter-select">
                    <option value="default">é»˜è®¤æ’åº</option>
                    <option value="anki">ANKIæ’åº</option>
                </select>
                <button id="reset-chapter" class="reset-btn">é‡ç½®æœ¬ç« è¿›åº¦</button>
                <div class="stats">
                    <span>æ€»è®¡: <strong id="total-count">0</strong></span>
                    <span>å·²æŒæ¡: <strong id="mastered-count">0</strong></span>
                    <span>å­¦ä¹ ä¸­: <strong id="learning-count">0</strong></span>
                </div>
            </div>
        </header>

        <main>
            <div class="words-container" id="words-container">
                <!-- å•è¯å¡ç‰‡å°†é€šè¿‡JavaScriptåŠ¨æ€åŠ è½½ -->
            </div>
        </main>
    </div>

    <script src="progress.js"></script>
    <script src="anki.js"></script>
    <script>
        let chapterName = '';
        let wordsData = [];
        let learningProgress = JSON.parse(localStorage.getItem('learningProgress') || '{}');
        let displayMode = 'learning'; // 'learning', 'mastered', 'all'
        let sortMode = 'default'; // 'default', 'anki'

        // Update function for progress manager
        window.updateUIFromProgress = function() {
            learningProgress = JSON.parse(localStorage.getItem('learningProgress') || '{}');
            displayWords();
            updateStats();
        };
        
        // Make progress globally accessible
        window.learningProgress = learningProgress;

        // è·å–URLå‚æ•°
        function getUrlParams() {
            const params = new URLSearchParams(window.location.search);
            return {
                chapter: params.get('chapter'),
                file: params.get('file')
            };
        }

        // åŠ è½½ç« èŠ‚æ•°æ®
        async function loadChapterData() {
            const params = getUrlParams();
            chapterName = params.chapter;
            
            try {
                const response = await fetch(`json_chapters/${params.file}`);
                const data = await response.json();
                wordsData = data.words;
                
                document.getElementById('chapter-title').textContent = data.chapter;
                displayWords();
                updateStats();
            } catch (error) {
                console.error('Error loading chapter data:', error);
            }
        }

        // æ˜¾ç¤ºå•è¯åˆ—è¡¨
        function displayWords() {
            const container = document.getElementById('words-container');
            container.innerHTML = '';
            
            const chapterProgress = learningProgress[chapterName] || {};
            
            // Prepare words with their progress data
            let wordsToDisplay = wordsData.map((word, index) => ({
                word: word,
                index: index,
                progress: chapterProgress[word.word] || null
            }));
            
            // Filter by display mode
            wordsToDisplay = wordsToDisplay.filter(item => {
                const progress = item.progress;
                if (displayMode === 'all') return true;
                if (displayMode === 'mastered') return progress && progress.mastered;
                if (displayMode === 'learning') return !progress || !progress.mastered;
                return true;
            });
            
            // Sort by selected mode
            if (sortMode === 'anki') {
                wordsToDisplay = ankiAlgorithm.sortByAnki(wordsToDisplay);
            }
            
            // Display filtered and sorted words
            wordsToDisplay.forEach(item => {
                const word = item.word;
                const index = item.index;
                const progress = item.progress;
                const isMastered = progress && progress.mastered;
                
                const wordCard = document.createElement('div');
                wordCard.className = `word-card ${isMastered ? 'mastered' : ''}`;
                wordCard.id = `word-${index}`;
                
                const reviewCount = progress ? progress.reviewCount || 0 : 0;
                const needsReview = progress && ankiAlgorithm.needsReview(progress);
                
                let wordHtml = `
                    <div class="word-header">
                        <div class="word-title-group">
                            <h3 class="word-title">
                                ${word.word}
                                <span class="word-pos">${word.pos}</span>
                                ${reviewCount > 0 ? `<span class="review-badge">å¤ä¹ ${reviewCount}æ¬¡</span>` : ''}
                                ${needsReview ? `<span class="needs-review-badge">éœ€å¤ä¹ </span>` : ''}
                            </h3>
                            ${word.phonetic ? `
                            <div class="word-phonetic">
                                <span>${word.phonetic}</span>
                                <button class="speak-btn" onclick="speakWord('${word.word.replace(/'/g, "\\'")}')">
                                    ğŸ”Š
                                </button>
                            </div>` : ''}
                        </div>
                        <div class="word-actions">
                            ${!isMastered ? `
                                <button class="review-btn" onclick="addReview('${word.word}', ${index})">
                                    å¤ä¹  +1
                                </button>
                            ` : ''}
                            <button class="master-btn ${isMastered ? 'is-mastered' : ''}" 
                                    onclick="toggleMastered('${word.word}', ${index})">
                                ${isMastered ? 'å·²æŒæ¡ âœ“' : 'æ ‡è®°æŒæ¡'}
                            </button>
                            ${isMastered ? `
                                <button class="relearn-btn" onclick="relearnWord('${word.word}', ${index})">
                                    é‡æ–°å­¦ä¹ 
                                </button>
                            ` : ''}
                        </div>
                    </div>
                    <div class="word-content">
                        <p class="word-meaning">${word.meaning}</p>
                `;
                
                if (word.example) {
                    wordHtml += `<p class="word-example">ä¾‹å¥: ${word.example}</p>`;
                }
                
                if (word.note) {
                    wordHtml += `<p class="word-note">ç¬”è®°: ${word.note}</p>`;
                }
                
                if (word.tips) {
                    wordHtml += `<p class="word-tips">ğŸ’¡ è®°å¿†æŠ€å·§: ${word.tips}</p>`;
                }
                
                wordHtml += '</div>';
                wordCard.innerHTML = wordHtml;
                container.appendChild(wordCard);
            });
            
            if (container.innerHTML === '') {
                let message = '';
                if (displayMode === 'learning') {
                    message = 'æ‰€æœ‰å•è¯éƒ½å·²æŒæ¡ï¼åˆ‡æ¢åˆ°"å…¨éƒ¨"æˆ–"å·²æŒæ¡"æŸ¥çœ‹ã€‚';
                } else if (displayMode === 'mastered') {
                    message = 'è¿˜æ²¡æœ‰æŒæ¡ä»»ä½•å•è¯ã€‚';
                } else {
                    message = 'æœ¬ç« èŠ‚æš‚æ— å•è¯ã€‚';
                }
                container.innerHTML = `<p class="empty-message">${message}</p>`;
            }
        }

        // æ·»åŠ å¤ä¹ æ¬¡æ•°
        function addReview(word, index) {
            if (!learningProgress[chapterName]) {
                learningProgress[chapterName] = {};
            }
            
            if (!learningProgress[chapterName][word]) {
                learningProgress[chapterName][word] = {
                    mastered: false,
                    reviewCount: 0,
                    lastReview: null,
                    nextReview: null
                };
            }
            
            const wordProgress = learningProgress[chapterName][word];
            wordProgress.reviewCount++;
            wordProgress.lastReview = new Date().toISOString();
            wordProgress.nextReview = ankiAlgorithm.getNextReviewTime(wordProgress.reviewCount);
            
            // ä¿å­˜åˆ°localStorage
            localStorage.setItem('learningProgress', JSON.stringify(learningProgress));
            window.learningProgress = learningProgress;
            
            // åŒæ­¥åˆ°äº‘ç«¯
            if (window.progressManager) {
                progressManager.saveToGist(learningProgress);
            }
            
            // æ›´æ–°æ˜¾ç¤º
            displayWords();
            updateStats();
        }

        // åˆ‡æ¢å•è¯æŒæ¡çŠ¶æ€
        function toggleMastered(word, index) {
            if (!learningProgress[chapterName]) {
                learningProgress[chapterName] = {};
            }
            
            if (!learningProgress[chapterName][word]) {
                learningProgress[chapterName][word] = {
                    mastered: false,
                    reviewCount: 0,
                    lastReview: null,
                    nextReview: null
                };
            }
            
            const wordProgress = learningProgress[chapterName][word];
            wordProgress.mastered = !wordProgress.mastered;
            wordProgress.lastReview = new Date().toISOString();
            
            if (wordProgress.mastered) {
                wordProgress.nextReview = null; // æŒæ¡åä¸éœ€è¦å¤ä¹ 
            } else {
                wordProgress.nextReview = ankiAlgorithm.getNextReviewTime(wordProgress.reviewCount);
            }
            
            // ä¿å­˜åˆ°localStorage
            localStorage.setItem('learningProgress', JSON.stringify(learningProgress));
            window.learningProgress = learningProgress;
            
            // åŒæ­¥åˆ°äº‘ç«¯
            if (window.progressManager) {
                progressManager.saveToGist(learningProgress);
            }
            
            // æ›´æ–°æ˜¾ç¤º
            displayWords();
            updateStats();
        }

        // é‡æ–°å­¦ä¹ å•è¯
        function relearnWord(word, index) {
            if (!learningProgress[chapterName] || !learningProgress[chapterName][word]) {
                return;
            }
            
            const wordProgress = learningProgress[chapterName][word];
            wordProgress.mastered = false;
            wordProgress.reviewCount = 0;
            wordProgress.lastReview = new Date().toISOString();
            wordProgress.nextReview = ankiAlgorithm.getNextReviewTime(0);
            
            // ä¿å­˜åˆ°localStorage
            localStorage.setItem('learningProgress', JSON.stringify(learningProgress));
            window.learningProgress = learningProgress;
            
            // åŒæ­¥åˆ°äº‘ç«¯
            if (window.progressManager) {
                progressManager.saveToGist(learningProgress);
            }
            
            // æ›´æ–°æ˜¾ç¤º
            displayWords();
            updateStats();
        }

        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        function updateStats() {
            const chapterProgress = learningProgress[chapterName] || {};
            const stats = ankiAlgorithm.getChapterStats(chapterProgress, wordsData.length);
            
            document.getElementById('total-count').textContent = wordsData.length;
            document.getElementById('mastered-count').textContent = stats.mastered;
            document.getElementById('learning-count').textContent = stats.learning + stats.needReview + stats.new;
        }

        // æ˜¾ç¤ºæ¨¡å¼åˆ‡æ¢
        document.getElementById('display-mode').addEventListener('change', function() {
            displayMode = this.value;
            displayWords();
        });

        // æ’åºæ¨¡å¼åˆ‡æ¢
        document.getElementById('sort-mode').addEventListener('change', function() {
            sortMode = this.value;
            displayWords();
        });

        // é‡ç½®æœ¬ç« è¿›åº¦
        document.getElementById('reset-chapter').addEventListener('click', function() {
            if (confirm(`ç¡®å®šè¦é‡ç½®"${chapterName}"ç« èŠ‚çš„æ‰€æœ‰è¿›åº¦å—ï¼Ÿ`)) {
                delete learningProgress[chapterName];
                localStorage.setItem('learningProgress', JSON.stringify(learningProgress));
                window.learningProgress = learningProgress;
                
                // åŒæ­¥åˆ°äº‘ç«¯
                if (window.progressManager) {
                    progressManager.saveToGist(learningProgress);
                }
                
                displayWords();
                updateStats();
            }
        });

        // TTS å‘éŸ³åŠŸèƒ½
        function speakWord(word) {
            // æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ”¯æŒè¯­éŸ³åˆæˆ
            if ('speechSynthesis' in window) {
                // åœæ­¢å½“å‰æ’­æ”¾çš„è¯­éŸ³
                speechSynthesis.cancel();
                
                // åˆ›å»ºæ–°çš„è¯­éŸ³å®ä¾‹
                const utterance = new SpeechSynthesisUtterance(word);
                
                // è®¾ç½®è¯­éŸ³å‚æ•°
                utterance.lang = 'en-US'; // è‹±è¯­ç¾éŸ³
                utterance.rate = 0.8; // è¯­é€Ÿç¨æ…¢ï¼Œä¾¿äºå­¦ä¹ 
                utterance.pitch = 1; // æ­£å¸¸éŸ³è°ƒ
                utterance.volume = 1; // æœ€å¤§éŸ³é‡
                
                // è·å–å¯ç”¨çš„è¯­éŸ³åˆ—è¡¨
                const voices = speechSynthesis.getVoices();
                
                // ä¼˜å…ˆé€‰æ‹©è‹±è¯­æ¯è¯­è€…çš„å£°éŸ³
                const englishVoice = voices.find(voice => 
                    voice.lang.startsWith('en') && voice.localService
                ) || voices.find(voice => voice.lang.startsWith('en'));
                
                if (englishVoice) {
                    utterance.voice = englishVoice;
                }
                
                // æ’­æ”¾è¯­éŸ³
                speechSynthesis.speak(utterance);
                
                // é”™è¯¯å¤„ç†
                utterance.onerror = function(event) {
                    console.error('Speech synthesis error:', event.error);
                };
            } else {
                alert('ä½ çš„æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³åˆæˆåŠŸèƒ½');
            }
        }

        // ç¡®ä¿è¯­éŸ³åˆ—è¡¨å·²åŠ è½½
        function loadVoices() {
            return new Promise((resolve) => {
                let voices = speechSynthesis.getVoices();
                if (voices.length > 0) {
                    resolve(voices);
                } else {
                    speechSynthesis.onvoiceschanged = () => {
                        voices = speechSynthesis.getVoices();
                        resolve(voices);
                    };
                }
            });
        }

        // åˆå§‹åŒ–é¡µé¢
        loadChapterData();
        
        // é¢„åŠ è½½è¯­éŸ³åˆ—è¡¨
        if ('speechSynthesis' in window) {
            loadVoices();
        }
        
        // Setup sync UI after page loads
        setTimeout(() => progressManager.setupUI(), 100);
    </script>
</body>
</html>